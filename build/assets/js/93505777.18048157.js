"use strict";(self.webpackChunkthree_horizons_docusaurus=self.webpackChunkthree_horizons_docusaurus||[]).push([[362],{8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>a});var o=t(6540);const s={},i=o.createContext(s);function r(n){const e=o.useContext(i);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),o.createElement(i.Provider,{value:e},n.children)}},9134:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>p,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>o,toc:()=>u});const o=JSON.parse('{"id":"phase5-cicd","title":"Phase 5: CI/CD Pipeline Setup","description":"In this phase, we\'ll set up continuous integration and continuous deployment (CI/CD) pipelines to automate the build, test, and deployment processes for your applications.","source":"@site/docs/phase5-cicd.md","sourceDirName":".","slug":"/phase5-cicd","permalink":"/three-horizon-site/docs/phase5-cicd","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Phase 4: GitHub Integration","permalink":"/three-horizon-site/docs/phase4-github"},"next":{"title":"Phase 6: Monitoring & Observability","permalink":"/three-horizon-site/docs/phase6-monitoring"}}');var s=t(4848),i=t(8453);const r={sidebar_position:6},a="Phase 5: CI/CD Pipeline Setup",p={},u=[{value:"Step 5.1: Set Up GitOps Repository Structure",id:"step-51-set-up-gitops-repository-structure",level:2},{value:"Step 5.2: Configure Flux for GitOps",id:"step-52-configure-flux-for-gitops",level:2},{value:"Step 5.3: Configure GitHub Actions for CI",id:"step-53-configure-github-actions-for-ci",level:2},{value:"Step 5.4: Configure GitHub Actions for CD",id:"step-54-configure-github-actions-for-cd",level:2},{value:"Step 5.5: Configure Deployment Approvals",id:"step-55-configure-deployment-approvals",level:2}];function c(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"phase-5-cicd-pipeline-setup",children:"Phase 5: CI/CD Pipeline Setup"})}),"\n",(0,s.jsx)(e.p,{children:"In this phase, we'll set up continuous integration and continuous deployment (CI/CD) pipelines to automate the build, test, and deployment processes for your applications."}),"\n",(0,s.jsx)(e.h2,{id:"step-51-set-up-gitops-repository-structure",children:"Step 5.1: Set Up GitOps Repository Structure"}),"\n",(0,s.jsx)(e.p,{children:"First, create a GitOps repository structure to manage your Kubernetes configurations:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Create a new repository in your GitHub organization\n# Clone it locally\ngit clone https://github.com/your-org/three-horizons-gitops.git\ncd three-horizons-gitops\n\n# Create directory structure\nmkdir -p {base,overlays}/{dev,staging,prod}\n\n# Create base kustomization file\ncat > base/kustomization.yaml <<EOF\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n- deployment.yaml\n- service.yaml\nEOF\n\n# Create base deployment template\ncat > base/deployment.yaml <<EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-deployment\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: three-horizons-app\n  template:\n    metadata:\n      labels:\n        app: three-horizons-app\n    spec:\n      containers:\n      - name: app\n        image: \\${ACR_SERVER}/app:latest\n        ports:\n        - containerPort: 8080\n        resources:\n          limits:\n            cpu: "1"\n            memory: "1Gi"\n          requests:\n            cpu: "500m"\n            memory: "512Mi"\nEOF\n\n# Create base service template\ncat > base/service.yaml <<EOF\napiVersion: v1\nkind: Service\nmetadata:\n  name: app-service\nspec:\n  selector:\n    app: three-horizons-app\n  ports:\n  - port: 80\n    targetPort: 8080\n  type: ClusterIP\nEOF\n\n# Create environment-specific overlays\nfor env in dev staging prod; do\n  cat > overlays/$env/kustomization.yaml <<EOF\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nnamespace: three-horizons-$env\nresources:\n- ../../base\n- namespace.yaml\npatchesStrategicMerge:\n- deployment-patch.yaml\nEOF\n\n  cat > overlays/$env/namespace.yaml <<EOF\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: three-horizons-$env\nEOF\n\n  cat > overlays/$env/deployment-patch.yaml <<EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-deployment\nspec:\n  replicas: $([ "$env" == "prod" ] && echo "3" || echo "1")\nEOF\ndone\n\n# Commit and push the GitOps structure\ngit add .\ngit commit -m "Initial GitOps repository structure"\ngit push\n'})}),"\n",(0,s.jsx)(e.h2,{id:"step-52-configure-flux-for-gitops",children:"Step 5.2: Configure Flux for GitOps"}),"\n",(0,s.jsx)(e.p,{children:"Install and configure Flux to manage GitOps deployments:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Install Flux CLI\ncurl -s https://fluxcd.io/install.sh | sudo bash\n\n# Check prerequisites\nflux check --pre\n\n# Bootstrap Flux on your cluster\nflux bootstrap github \\\n  --owner=your-org \\\n  --repository=three-horizons-gitops \\\n  --branch=main \\\n  --path=./clusters/three-horizons \\\n  --personal\n\n# Create a source for your GitOps repository\nflux create source git three-horizons-gitops \\\n  --url=https://github.com/your-org/three-horizons-gitops \\\n  --branch=main \\\n  --interval=1m\n\n# Create Kustomization for each environment\nfor env in dev staging prod; do\n  flux create kustomization three-horizons-$env \\\n    --source=three-horizons-gitops \\\n    --path="./overlays/$env" \\\n    --prune=true \\\n    --interval=5m\ndone\n'})}),"\n",(0,s.jsx)(e.h2,{id:"step-53-configure-github-actions-for-ci",children:"Step 5.3: Configure GitHub Actions for CI"}),"\n",(0,s.jsx)(e.p,{children:"Set up GitHub Actions workflows for continuous integration:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"# Save as .github/workflows/ci.yml in your application repositories\n\nname: Continuous Integration\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main, develop ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Set up Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      \n      - name: Install dependencies\n        run: npm ci\n      \n      - name: Lint code\n        run: npm run lint\n      \n      - name: Run unit tests\n        run: npm test\n      \n      - name: Run integration tests\n        run: npm run test:integration\n      \n      - name: Build\n        run: npm run build\n      \n      - name: Upload build artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: build-artifacts\n          path: dist/\n"})}),"\n",(0,s.jsx)(e.h2,{id:"step-54-configure-github-actions-for-cd",children:"Step 5.4: Configure GitHub Actions for CD"}),"\n",(0,s.jsx)(e.p,{children:"Set up GitHub Actions workflows for continuous deployment:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:'# Save as .github/workflows/cd.yml in your application repositories\n\nname: Continuous Deployment\n\non:\n  push:\n    branches: [ main ]\n    tags: [ \'v*\' ]\n\njobs:\n  build-and-push:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      \n      - name: Login to ACR\n        uses: docker/login-action@v2\n        with:\n          registry: ${{ secrets.ACR_SERVER }}\n          username: ${{ secrets.ACR_USERNAME }}\n          password: ${{ secrets.ACR_PASSWORD }}\n      \n      - name: Extract metadata\n        id: meta\n        uses: docker/metadata-action@v4\n        with:\n          images: ${{ secrets.ACR_SERVER }}/${{ github.repository }}\n          tags: |\n            type=semver,pattern={{version}}\n            type=ref,event=branch\n            type=sha,format=short\n      \n      - name: Build and push Docker image\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n      \n      - name: Update GitOps repository\n        uses: actions/checkout@v3\n        with:\n          repository: your-org/three-horizons-gitops\n          token: ${{ secrets.GITOPS_PAT }}\n          path: gitops\n      \n      - name: Update image tag in GitOps repository\n        run: |\n          cd gitops\n          # Determine environment based on branch or tag\n          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then\n            ENV="staging"\n          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then\n            ENV="prod"\n          else\n            ENV="dev"\n          fi\n          \n          # Update the image tag in the appropriate environment\n          IMAGE_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n 1)\n          sed -i "s|image: .*|image: $IMAGE_TAG|" overlays/$ENV/deployment-patch.yaml\n          \n          # Commit and push changes\n          git config user.name "GitHub Actions"\n          git config user.email "actions@github.com"\n          git add overlays/$ENV/deployment-patch.yaml\n          git commit -m "Update image to $IMAGE_TAG in $ENV environment"\n          git push\n'})}),"\n",(0,s.jsx)(e.h2,{id:"step-55-configure-deployment-approvals",children:"Step 5.5: Configure Deployment Approvals"}),"\n",(0,s.jsx)(e.p,{children:"Set up deployment approvals for production environments:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:'# Save as .github/workflows/approval.yml in your application repositories\n\nname: Production Deployment Approval\n\non:\n  workflow_run:\n    workflows: ["Continuous Deployment"]\n    types:\n      - completed\n    branches:\n      - main\n\njobs:\n  wait-for-approval:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == \'success\' }}\n    environment: production-approval\n    steps:\n      - name: Approval notification\n        run: echo "Production deployment has been approved"\n      \n  deploy-to-production:\n    needs: wait-for-approval\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          repository: your-org/three-horizons-gitops\n          token: ${{ secrets.GITOPS_PAT }}\n      \n      - name: Promote staging to production\n        run: |\n          # Copy the current staging image to production\n          STAGING_IMAGE=$(grep -o \'image: .*\' overlays/staging/deployment-patch.yaml)\n          sed -i "s|image: .*|$STAGING_IMAGE|" overlays/prod/deployment-patch.yaml\n          \n          # Commit and push changes\n          git config user.name "GitHub Actions"\n          git config user.email "actions@github.com"\n          git add overlays/prod/deployment-patch.yaml\n          git commit -m "Promote staging image to production"\n          git push\n'})}),"\n",(0,s.jsxs)(e.admonition,{type:"tip",children:[(0,s.jsx)(e.p,{children:"For more advanced CI/CD patterns, consider implementing:"}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Canary deployments"}),"\n",(0,s.jsx)(e.li,{children:"Blue/green deployments"}),"\n",(0,s.jsx)(e.li,{children:"Feature flags"}),"\n",(0,s.jsx)(e.li,{children:"Automated rollbacks"}),"\n"]})]})]})}function l(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}}}]);